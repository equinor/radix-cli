// Copyright Â© 2023
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"errors"
	"fmt"
	"os"
	"strings"

	radixapi "github.com/equinor/radix-cli/generated/radixapi/client"
	"github.com/equinor/radix-cli/generated/radixapi/client/environment"
	radixapimodels "github.com/equinor/radix-cli/generated/radixapi/models"
	vulnscanapi "github.com/equinor/radix-cli/generated/vulnscanapi/client"
	"github.com/equinor/radix-cli/generated/vulnscanapi/client/vulnerability"
	"github.com/equinor/radix-cli/generated/vulnscanapi/models"
	"github.com/equinor/radix-cli/pkg/client"
	"github.com/equinor/radix-cli/pkg/config"
	"github.com/equinor/radix-cli/pkg/flagnames"
	"github.com/equinor/radix-cli/pkg/utils/completion"
	"github.com/equinor/radix-cli/pkg/utils/json"
	"github.com/equinor/radix-common/utils/slice"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

var errCriticalVulnerabilityFound = errors.New("critical vulnerability found")

// getVulnerabilityCmd represents the getVulnerabilityCmd command
var getVulnerabilityCmd = &cobra.Command{
	Use:   "vulnerability",
	Short: "Gets vulnerability scan results for a given application",
	Long: `Gets vulnerability scan results for a given application and deployment name or environment

Examples:
  # Get a vulnerability scan results for an application radix-test 
  rx get vulnerability --application radix-test

  # Get a vulnerability scan results for component frontend for an application radix-test, this also includes details about the vulnerability instead of a summary
  rx get vulnerability --application radix-test --component frontend

  # Get a vulnerability scan results for job compute for an application radix-test, this also includes details about the vulnerability instead of a summary
  rx get vulnerability --application radix-test --job compute

  # Get a vulnerability scan results for an application radix-test and its environment test
  rx get vulnerability --application radix-test --environment test

  # Get a vulnerability scan results for an application radix-test and output json
  rx get vulnerability --application radix-test --json
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		outputFormat, _ := cmd.Flags().GetString(flagnames.Output)
		exitOnCritical, _ := cmd.Flags().GetBool(flagnames.FailCritical)
		appName, err := config.GetAppNameFromConfigOrFromParameter(cmd, flagnames.Application)
		if err != nil {
			return err
		}
		if appName == "" {
			return errors.New("application name is required field")
		}

		componentName, err := cmd.Flags().GetString(flagnames.Component)
		if err != nil {
			return err
		}
		envName, err := cmd.Flags().GetString(flagnames.Environment)
		if err != nil {
			return err
		}
		if componentName != "" && envName == "" {
			return errors.New("options component and environment must be used together")
		}

		cmd.SilenceUsage = true

		apiClient, err := client.GetVulnerabilityScanApiForCommand(cmd)
		if err != nil {
			return err
		}

		radixApi, err := client.GetRadixApiForCommand(cmd)
		if err != nil {
			return err
		}

		if componentName != "" {
			err = getVulnerabilityScanForComponentOrJob(radixApi, apiClient, appName, envName, componentName, outputFormat)
		} else if envName != "" {
			err = getVulnerabilityScanForEnvironment(apiClient, appName, envName, outputFormat)
		} else {
			err = getVulnerabilityScanForApplication(apiClient, appName, outputFormat)
		}

		if errors.Is(err, errCriticalVulnerabilityFound) {
			cmd.PrintErr(color.RedString(err.Error()), "\n")

			if exitOnCritical {
				os.Exit(2)
			}
			return nil
		}

		return err
	},
}

func getVulnerabilityScanForComponentOrJob(radixApi *radixapi.Radixapi, apiClient *vulnscanapi.Vulnscanapi, appName, envName, componentName, outputFormat string) error {
	GetEnvironmentParams := environment.NewGetEnvironmentParams().WithEnvName(envName).WithAppName(appName)
	resp, err := radixApi.Environment.GetEnvironment(GetEnvironmentParams, nil)
	if err != nil || resp.Payload == nil || resp.Payload.ActiveDeployment == nil {
		return err
	}
	isComponent := slice.Any(resp.Payload.ActiveDeployment.Components, func(c *radixapimodels.Component) bool {
		return *c.Type == "component" && *c.Name == componentName
	})

	isJob := slice.Any(resp.Payload.ActiveDeployment.Components, func(c *radixapimodels.Component) bool {
		return *c.Type == "job" && *c.Name == componentName
	})

	if isComponent {
		return getVulnerabilityScanForComponent(apiClient, appName, envName, componentName, outputFormat)
	} else if isJob {
		return getVulnerabilityScanForJob(apiClient, appName, envName, componentName, outputFormat)
	}
	return errors.New("job or component not found")
}

func getVulnerabilityScanForApplication(apiClient *vulnscanapi.Vulnscanapi, appName, outputFormat string) error {
	params := vulnerability.NewGetApplicationVulnerabilitySummariesParams()
	params.WithAppName(appName)
	resp, err := apiClient.Vulnerability.GetApplicationVulnerabilitySummaries(params, nil)
	if err != nil {
		return err
	}

	if outputFormat == "json" {
		if err = prettyPrintJson(resp.Payload); err != nil {
			return err
		}

		return assertHasCriticalError(resp.Payload)
	}

	for _, vulnerabilities := range resp.Payload {
		prettyPrintTextComponentVulnerabilities(*vulnerabilities.Name, vulnerabilities.Components, vulnerabilities.Jobs)
		fmt.Println()
	}
	return assertHasCriticalError(resp.Payload)
}

func getVulnerabilityScanForEnvironment(apiClient *vulnscanapi.Vulnscanapi, appName, envName, outputFormat string) error {
	params := vulnerability.NewGetEnvironmentVulnerabilitySummaryParams()
	params.WithAppName(appName)
	params.WithEnvName(envName)
	resp, err := apiClient.Vulnerability.GetEnvironmentVulnerabilitySummary(params, nil)
	if err != nil {
		return err
	}

	if outputFormat == "json" {
		if err = prettyPrintJson(resp.Payload); err != nil {
			return err
		}
		return assertHasCriticalError(resp.Payload)
	}

	prettyPrintTextComponentVulnerabilities(*resp.Payload.Name, resp.Payload.Components, resp.Payload.Jobs)

	return assertHasCriticalError(resp.Payload)
}

func getVulnerabilityScanForComponent(apiClient *vulnscanapi.Vulnscanapi, appName, envName, componentName, outputFormat string) error {
	params := vulnerability.NewGetComponentVulnerabilitiesParams()
	params.WithAppName(appName)
	params.WithComponentName(componentName)
	params.WithEnvName(envName)
	resp, err := apiClient.Vulnerability.GetComponentVulnerabilities(params, nil)
	if err != nil {
		return err
	}

	if outputFormat == "json" {
		if err = prettyPrintJson(resp.Payload); err != nil {
			return err
		}
		return assertHasCriticalError(resp.Payload)
	}

	fmt.Printf("# %s\n", componentName)
	fmt.Printf("image: %s\n", *resp.Payload.ImageName)
	fmt.Printf("scanned: %s\n", resp.Payload.ScanTime)
	if len(resp.Payload.VulnerabilitySummary) == 0 {
		color.Green("No vulnerabilities found")
		return assertHasCriticalError(resp.Payload)
	}

	fmt.Println()
	for _, vulnerability := range resp.Payload.Vulnerabilities {
		prettyPrintVulnerability(vulnerability)
	}
	return assertHasCriticalError(resp.Payload)
}

func getVulnerabilityScanForJob(apiClient *vulnscanapi.Vulnscanapi, appName, envName, jobName, outputFormat string) error {
	params := vulnerability.NewGetJobVulnerabilitiesParams()
	params.WithAppName(appName)
	params.WithJobName(jobName)
	params.WithEnvName(envName)
	resp, err := apiClient.Vulnerability.GetJobVulnerabilities(params, nil)
	if err != nil {
		return err
	}

	if outputFormat == "json" {
		if err = prettyPrintJson(resp.Payload); err != nil {
			return err
		}
		return assertHasCriticalError(resp.Payload)
	}

	fmt.Printf("# %s\n", jobName)
	fmt.Printf("image: %s\n", *resp.Payload.ImageName)
	fmt.Printf("scanned: %s\n", resp.Payload.ScanTime)
	if len(resp.Payload.VulnerabilitySummary) == 0 {
		color.Green("No vulnerabilities found")
		return assertHasCriticalError(resp.Payload)
	}

	fmt.Println()
	for _, vulnerability := range resp.Payload.Vulnerabilities {
		prettyPrintVulnerability(vulnerability)
	}

	return assertHasCriticalError(resp.Payload)
}

func prettyPrintVulnerability(vulnerability *models.Vulnerability) {
	firstReference := ""
	if len(vulnerability.References) >= 1 {
		firstReference = vulnerability.References[0]
	}

	score := "-.-"
	if vulnerability.CVSS > 0.0 {
		score = fmt.Sprintf("%.1f", vulnerability.CVSS)
	}

	if *vulnerability.Severity == "critical" {
		color.Red("CVSS: %s: %-60s - %s\n", score, vulnerability.Title, firstReference)
	} else {
		fmt.Printf("CVSS: %s: %-60s - %s\n", score, vulnerability.Title, firstReference)
	}
}

func prettyPrintTextComponentVulnerabilities(envName string, components, jobs models.ComponentVulnerabilities) {
	fmt.Printf("# %s environment:\n", envName)
	if len(components) == 0 && len(jobs) == 0 {
		color.Green("No vulnerabilities found")
		return
	}

	if len(components) > 0 {
		fmt.Printf("- Components:\n")
		for compName, component := range components {
			printVulnerabilitySummary(compName, component.VulnerabilitySummary)
		}
	}

	if len(jobs) > 0 {
		fmt.Printf("- Jobs:\n")
		for jobName, job := range jobs {
			printVulnerabilitySummary(jobName, job.VulnerabilitySummary)
		}
	}
}

func printVulnerabilitySummary(name string, summary map[string]int64) {
	_, hasCritical := summary["critical"]

	var summaries []string
	for level, count := range summary {
		summaries = append(summaries, fmt.Sprintf("%d %s", count, level))
	}

	if len(summaries) == 0 {
		color.Green("  - %s: No vulnerabilities found\n", name)
	} else if hasCritical {
		color.Red("  - %s: %s\n", name, strings.Join(summaries, ", "))
	} else {
		fmt.Printf("  - %s: %s\n", name, strings.Join(summaries, ", "))
	}
}

func prettyPrintJson(data interface{}) error {
	prettyJSON, err := json.Pretty(data)
	if err != nil {
		return err
	}
	fmt.Println(*prettyJSON)
	return nil
}

func assertHasCriticalError(payload any) error {
	switch p := payload.(type) {
	case models.ApplicationVulnerabilities:
		for _, vulnerabilities := range p {
			for _, scan := range vulnerabilities.Jobs {
				if _, ok := scan.VulnerabilitySummary["critical"]; ok {
					return errCriticalVulnerabilityFound
				}
			}
			for _, scan := range vulnerabilities.Components {
				if _, ok := scan.VulnerabilitySummary["critical"]; ok {
					return errCriticalVulnerabilityFound
				}
			}
		}
	case *models.EnvironmentVulnerabilities:
		for _, scan := range p.Jobs {
			if _, ok := scan.VulnerabilitySummary["critical"]; ok {
				return errCriticalVulnerabilityFound
			}
		}
		for _, scan := range p.Components {
			if _, ok := scan.VulnerabilitySummary["critical"]; ok {
				return errCriticalVulnerabilityFound
			}
		}
	case *models.ImageWithLastScan:
		if _, ok := p.VulnerabilitySummary["critical"]; ok {
			return errCriticalVulnerabilityFound
		}
	default:
		return errors.New("unknown payload")
	}

	return nil
}

func init() {
	getCmd.AddCommand(getVulnerabilityCmd)
	getVulnerabilityCmd.Flags().StringP(flagnames.Application, "a", "", "Name of the application")
	getVulnerabilityCmd.Flags().StringP(flagnames.Environment, "e", "", "Optional, name of the environment")
	getVulnerabilityCmd.Flags().StringP(flagnames.Component, "", "", "Optional, name of a component or job. Requires 'environment'")
	getVulnerabilityCmd.Flags().StringP(flagnames.Output, "", "text", "Optional, output json instead of text formatting")
	getVulnerabilityCmd.Flags().BoolP(flagnames.FailCritical, "", false, "Fail with exitcode 2 if a critical vulnerability is found")

	_ = getVulnerabilityCmd.RegisterFlagCompletionFunc(flagnames.Application, completion.ApplicationCompletion)
	_ = getVulnerabilityCmd.RegisterFlagCompletionFunc(flagnames.Environment, completion.EnvironmentCompletion)
	_ = getVulnerabilityCmd.RegisterFlagCompletionFunc(flagnames.Job, completion.JobCompletion)
	_ = getVulnerabilityCmd.RegisterFlagCompletionFunc(flagnames.Component, completion.ComponentCompletion)
	_ = getVulnerabilityCmd.RegisterFlagCompletionFunc(flagnames.Output, completion.Output)
	setContextSpecificPersistentFlags(getVulnerabilityCmd)
}
